{"ast":null,"code":"import theme from '../config/theme';\nimport { getCanvasHeightFromTreeHeight, getRequiredAndActualHeightAndWidth, getXPositionFromGivenHorizontalNodePosition } from '../utils/tree';\nimport connectPointsWithBezierCurve from '../utils/connectPointsWithBezierCurve';\n/**\n * The current animation frame that is going on\n */\n\nlet animationFrameId;\n/**\n * Current color that is being hovered on\n */\n\nlet hoveredColorId;\n/**\n * Spacing map for storing space requirements\n */\n\nlet spacingMap;\n/**\n * Clear the existing animation frame if any and request an animation frame\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {Point} position\n * @param {boolean} highlightMode\n */\n\nfunction requestAnimationFrame(root, canvasComponent, position, highlightMode) {\n  // Clear existing animation frame\n  if (animationFrameId) {\n    cancelAnimationFrame(animationFrameId);\n  } // Request a new one\n\n\n  animationFrameId = window.requestAnimationFrame(() => {\n    canvasComponent.clearCanvas();\n    const requiredRedraw = recursivelyDrawNodes(root, canvasComponent, position, highlightMode);\n\n    if (requiredRedraw) {\n      requestAnimationFrame(root, canvasComponent, position, highlightMode);\n    }\n  });\n}\n/**\n * Draw single node\n *\n * @param {BinaryTreeNode} node\n * @param {CanvasComponent} comp\n * @param {Point} position\n * @param {boolean} highlightMode\n * @return {boolean} Weather redraw is required\n */\n\n\nfunction drawSingleNode(node, comp, position, highlightMode) {\n  const {\n    x,\n    y\n  } = position;\n  node.nodeCircle.setCoordinates(x, y); // Grow or shrink while hover\n\n  const colorId = node.nodeCircle.draw(comp);\n\n  if (colorId === hoveredColorId && highlightMode) {\n    return node.nodeCircle.grow();\n  } else {\n    return node.nodeCircle.restoreCircle();\n  }\n}\n/**\n * Recursively draw all the nodes for a pretty tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {Point} position\n * @param {boolean} highlightMode\n * @return {boolean}\n */\n\n\nfunction recursivelyDrawNodes(root, canvasComponent, position, highlightMode) {\n  const {\n    x: xPosition,\n    y: yPosition\n  } = position; // Draw the node\n\n  let requiredRedraw = drawSingleNode(root, canvasComponent, {\n    x: xPosition,\n    y: yPosition\n  }, highlightMode);\n  root.nodeCircle.setCoordinates(xPosition, yPosition);\n  root.nodeCircle.draw(canvasComponent); // Root spacings\n\n  const {\n    left,\n    right\n  } = spacingMap.get(root); // Draw the left child\n\n  if (root.left) {\n    const leftOfLeft = spacingMap.get(root.left).left;\n    const childYPosition = yPosition + theme.lineHeight;\n    const leftPosition = {\n      x: xPosition - getXPositionFromGivenHorizontalNodePosition(left - leftOfLeft),\n      y: childYPosition\n    };\n    requiredRedraw = recursivelyDrawNodes(root.left, canvasComponent, leftPosition, highlightMode) || requiredRedraw;\n    connectPointsWithBezierCurve(canvasComponent, {\n      xStart: xPosition,\n      xEnd: leftPosition.x\n    }, {\n      yStart: yPosition + root.nodeCircle.getRadius(),\n      yEnd: childYPosition - root.left.nodeCircle.getRadius()\n    });\n  } // Draw the right child\n\n\n  if (root.right) {\n    const rightOfRight = spacingMap.get(root.right).right;\n    const childYPosition = yPosition + theme.lineHeight;\n    const rightPosition = {\n      x: xPosition + getXPositionFromGivenHorizontalNodePosition(right - rightOfRight),\n      y: childYPosition\n    };\n    requiredRedraw = recursivelyDrawNodes(root.right, canvasComponent, rightPosition, highlightMode) || requiredRedraw;\n    connectPointsWithBezierCurve(canvasComponent, {\n      xStart: xPosition,\n      xEnd: rightPosition.x\n    }, {\n      yStart: yPosition + root.nodeCircle.getRadius(),\n      yEnd: childYPosition - root.right.nodeCircle.getRadius()\n    });\n  }\n\n  return requiredRedraw;\n}\n/**\n * Calculates the spacing required recursively\n *\n * @param {BinaryTreeNode<string | number>} root\n * @return {number} - The spacing requirement of that node\n */\n\n\nfunction calculateSpacingMapRecursively(root) {\n  const left = root.left ? calculateSpacingMapRecursively(root.left) + 0.5 : 0;\n  const right = root.right ? calculateSpacingMapRecursively(root.right) + 0.5 : 0;\n  spacingMap.set(root, {\n    left,\n    right\n  });\n  return left + right;\n}\n/**\n * Draw a pretty binary tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {IndividualInputOptions} options\n */\n\n\nfunction drawPrettyBinaryTree(root, canvasComponent, options) {\n  spacingMap = new Map();\n  const maxNodeSpacing = calculateSpacingMapRecursively(root);\n  const heightOfTree = root.getHeight();\n  const {\n    maxHeight,\n    maxWidth,\n    highlightMode\n  } = options; // Calculate canvas spacing requirements\n\n  const {\n    maxCanvasWidthRequired,\n    actualMaxHeight,\n    actualMaxWidth\n  } = getRequiredAndActualHeightAndWidth(maxNodeSpacing, heightOfTree, maxWidth, maxHeight); // Init calculation\n\n  const left = spacingMap.get(root).left;\n  const midPointInCanvas = actualMaxWidth / 2;\n  const xStart = midPointInCanvas - maxCanvasWidthRequired / 2; // Initialize the canvas\n\n  canvasComponent.setMaxWidthAndHeight(actualMaxHeight, actualMaxWidth);\n  /**\n   * Hover event handler\n   */\n\n  canvasComponent.onHover(color => {\n    hoveredColorId = color;\n    requestAnimationFrame(root, canvasComponent, {\n      x: xStart + getXPositionFromGivenHorizontalNodePosition(left + 1),\n      y: getCanvasHeightFromTreeHeight(0.5)\n    }, Boolean(highlightMode));\n  }); // Recursively draw all nodes\n\n  requestAnimationFrame(root, canvasComponent, {\n    x: xStart + getXPositionFromGivenHorizontalNodePosition(left + 1),\n    y: getCanvasHeightFromTreeHeight(0.5)\n  }, Boolean(highlightMode));\n}\n\nexport default drawPrettyBinaryTree;","map":{"version":3,"mappings":"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","names":["theme","getCanvasHeightFromTreeHeight","getRequiredAndActualHeightAndWidth","getXPositionFromGivenHorizontalNodePosition","connectPointsWithBezierCurve","animationFrameId","hoveredColorId","spacingMap","requestAnimationFrame","root","canvasComponent","position","highlightMode","cancelAnimationFrame","window","clearCanvas","requiredRedraw","recursivelyDrawNodes","drawSingleNode","node","comp","x","y","nodeCircle","setCoordinates","colorId","draw","grow","restoreCircle","xPosition","yPosition","left","right","get","leftOfLeft","childYPosition","lineHeight","leftPosition","xStart","xEnd","yStart","getRadius","yEnd","rightOfRight","rightPosition","calculateSpacingMapRecursively","set","drawPrettyBinaryTree","options","Map","maxNodeSpacing","heightOfTree","getHeight","maxHeight","maxWidth","maxCanvasWidthRequired","actualMaxHeight","actualMaxWidth","midPointInCanvas","setMaxWidthAndHeight","onHover","color","Boolean"],"sources":["/home/denilson/node_modules/binary-tree-visualizer/src/canvas/drawPrettyBinaryTree.ts"],"sourcesContent":["import CanvasComponent from './Canvas';\nimport theme from '../config/theme';\nimport BinaryTreeNode from '../tree/BinaryTreeNode';\nimport {Point} from '../types/Point';\nimport {\n  getCanvasHeightFromTreeHeight,\n  getRequiredAndActualHeightAndWidth,\n  getXPositionFromGivenHorizontalNodePosition,\n} from '../utils/tree';\nimport connectPointsWithBezierCurve\n  from '../utils/connectPointsWithBezierCurve';\nimport {\n  IndividualInputOptions,\n  LeftAndRightSpacing,\n} from './types';\n\n/**\n * The current animation frame that is going on\n */\nlet animationFrameId: number;\n\n/**\n * Current color that is being hovered on\n */\nlet hoveredColorId: string;\n\n/**\n * Spacing map for storing space requirements\n */\nlet spacingMap: Map<BinaryTreeNode<string | number>, LeftAndRightSpacing>;\n\n/**\n * Clear the existing animation frame if any and request an animation frame\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {Point} position\n * @param {boolean} highlightMode\n */\nfunction requestAnimationFrame(\n    root: BinaryTreeNode<string | number>,\n    canvasComponent: CanvasComponent,\n    position: Point,\n    highlightMode: boolean,\n) {\n  // Clear existing animation frame\n  if (animationFrameId) {\n    cancelAnimationFrame(animationFrameId);\n  }\n\n  // Request a new one\n  animationFrameId = window.requestAnimationFrame(() => {\n    canvasComponent.clearCanvas();\n    const requiredRedraw = recursivelyDrawNodes(\n        root, canvasComponent, position, highlightMode);\n    if (requiredRedraw) {\n      requestAnimationFrame(root, canvasComponent, position, highlightMode);\n    }\n  });\n}\n\n/**\n * Draw single node\n *\n * @param {BinaryTreeNode} node\n * @param {CanvasComponent} comp\n * @param {Point} position\n * @param {boolean} highlightMode\n * @return {boolean} Weather redraw is required\n */\nfunction drawSingleNode(\n    node: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    position: Point,\n    highlightMode: boolean,\n) {\n  const {x, y} = position;\n  node.nodeCircle.setCoordinates(x, y);\n\n  // Grow or shrink while hover\n  const colorId = node.nodeCircle.draw(comp);\n  if (colorId === hoveredColorId && highlightMode) {\n    return node.nodeCircle.grow();\n  } else {\n    return node.nodeCircle.restoreCircle();\n  }\n}\n\n/**\n * Recursively draw all the nodes for a pretty tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {Point} position\n * @param {boolean} highlightMode\n * @return {boolean}\n */\nfunction recursivelyDrawNodes(\n    root: BinaryTreeNode<string | number>,\n    canvasComponent: CanvasComponent,\n    position: Point,\n    highlightMode: boolean,\n): boolean {\n  const {x: xPosition, y: yPosition} = position;\n\n  // Draw the node\n  let requiredRedraw = drawSingleNode(\n      root,\n      canvasComponent,\n      {x: xPosition, y: yPosition},\n      highlightMode,\n  );\n  root.nodeCircle.setCoordinates(xPosition, yPosition);\n  root.nodeCircle.draw(canvasComponent);\n\n  // Root spacings\n  const {left, right} = spacingMap.get(root)!;\n\n  // Draw the left child\n  if (root.left) {\n    const leftOfLeft = spacingMap.get(root.left)!.left;\n    const childYPosition = yPosition + theme.lineHeight;\n    const leftPosition = {\n      x: xPosition - getXPositionFromGivenHorizontalNodePosition(\n          left - leftOfLeft,\n      ),\n      y: childYPosition,\n    };\n\n    requiredRedraw = recursivelyDrawNodes(\n        root.left,\n        canvasComponent,\n        leftPosition,\n        highlightMode,\n    ) || requiredRedraw;\n    connectPointsWithBezierCurve(canvasComponent, {\n      xStart: xPosition,\n      xEnd: leftPosition.x,\n    }, {\n      yStart: yPosition + root.nodeCircle.getRadius(),\n      yEnd: childYPosition - root.left.nodeCircle.getRadius(),\n    });\n  }\n\n  // Draw the right child\n  if (root.right) {\n    const rightOfRight = spacingMap.get(root.right)!.right;\n    const childYPosition = yPosition + theme.lineHeight;\n    const rightPosition = {\n      x: xPosition + getXPositionFromGivenHorizontalNodePosition(\n          right - rightOfRight,\n      ),\n      y: childYPosition,\n    };\n\n    requiredRedraw = recursivelyDrawNodes(\n        root.right,\n        canvasComponent,\n        rightPosition,\n        highlightMode,\n    ) || requiredRedraw;\n    connectPointsWithBezierCurve(canvasComponent, {\n      xStart: xPosition,\n      xEnd: rightPosition.x,\n    }, {\n      yStart: yPosition + root.nodeCircle.getRadius(),\n      yEnd: childYPosition - root.right.nodeCircle.getRadius(),\n    });\n  }\n\n  return requiredRedraw;\n}\n\n/**\n * Calculates the spacing required recursively\n *\n * @param {BinaryTreeNode<string | number>} root\n * @return {number} - The spacing requirement of that node\n */\nfunction calculateSpacingMapRecursively(\n    root: BinaryTreeNode<string | number>,\n): number {\n  const left = root.left ? calculateSpacingMapRecursively(\n      root.left,\n  ) + 0.5: 0;\n  const right = root.right ? calculateSpacingMapRecursively(\n      root.right,\n  ) + 0.5: 0;\n  spacingMap.set(root, {\n    left,\n    right,\n  });\n\n  return left + right;\n}\n\n/**\n * Draw a pretty binary tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {IndividualInputOptions} options\n */\nfunction drawPrettyBinaryTree(\n    root: BinaryTreeNode<string | number>,\n    canvasComponent: CanvasComponent,\n    options: IndividualInputOptions,\n) {\n  spacingMap = new Map();\n  const maxNodeSpacing = calculateSpacingMapRecursively(root);\n  const heightOfTree = root.getHeight();\n  const {maxHeight, maxWidth, highlightMode} = options;\n\n  // Calculate canvas spacing requirements\n  const {\n    maxCanvasWidthRequired,\n    actualMaxHeight,\n    actualMaxWidth,\n  } = getRequiredAndActualHeightAndWidth(\n      maxNodeSpacing,\n      heightOfTree,\n      maxWidth,\n      maxHeight,\n  );\n\n  // Init calculation\n  const left = spacingMap.get(root)!.left;\n  const midPointInCanvas = actualMaxWidth / 2;\n  const xStart = (midPointInCanvas - maxCanvasWidthRequired / 2);\n\n  // Initialize the canvas\n  canvasComponent.setMaxWidthAndHeight(actualMaxHeight, actualMaxWidth);\n\n  /**\n   * Hover event handler\n   */\n  canvasComponent.onHover((color) => {\n    hoveredColorId = color;\n    requestAnimationFrame(root, canvasComponent, {\n      x: xStart + getXPositionFromGivenHorizontalNodePosition(left+1),\n      y: getCanvasHeightFromTreeHeight(0.5),\n    }, Boolean(highlightMode));\n  });\n\n  // Recursively draw all nodes\n  requestAnimationFrame(root, canvasComponent, {\n    x: xStart + getXPositionFromGivenHorizontalNodePosition(left+1),\n    y: getCanvasHeightFromTreeHeight(0.5),\n  }, Boolean(highlightMode));\n}\n\nexport default drawPrettyBinaryTree;\n"]},"metadata":{},"sourceType":"module"}