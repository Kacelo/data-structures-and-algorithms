{"ast":null,"code":"import theme from '../config/theme';\nimport { getCanvasHeightFromTreeHeight, getCanvasWidthFromMaxNodeSpacing, getXPositionFromGivenHorizontalNodePosition } from '../utils/tree';\nimport connectPointsWithBezierCurve from '../utils/connectPointsWithBezierCurve';\n/**\n * The current animation frame that is going on\n */\n\nlet animationFrameId;\n/**\n * Array of all children that needs printing\n */\n\nlet globalPathArray;\n/**\n * Current color that is being hovered on\n */\n\nlet hoveredColorId;\n/**\n * Map storing the colorId to the path array\n */\n\nlet colorIdToPathMap = new Map();\n/**\n * Clear the existing animation frame if any and request an animation frame\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} comp\n * @param {IndividualInputOptions} options\n */\n\nfunction requestAnimationFrame(root, comp, options) {\n  // Clear existing animation frame\n  if (animationFrameId) {\n    cancelAnimationFrame(animationFrameId);\n  } // Request a new one\n\n\n  animationFrameId = window.requestAnimationFrame(() => animationFrameCB(root, comp, options));\n}\n/**\n * Get the node height from print array\n *\n * @return {number}\n */\n\n\nfunction getNodeHeightFromGlobalPathArray() {\n  return globalPathArray.length + 1;\n}\n/**\n * Get the node width from the print array\n *\n * @return {{\n *  left: number,\n *  right: number\n * }}\n */\n\n\nfunction getNodeWidthFromGlobalPathArray() {\n  let left = 0;\n  let right = 0;\n  let current = 0;\n\n  for (const childDirection of globalPathArray) {\n    if (childDirection === 'left') {\n      current -= 1;\n    } else {\n      current += 1;\n    }\n\n    if (current < 0) {\n      left = Math.max(Math.abs(current), left);\n    } else {\n      right = Math.max(current, right);\n    }\n  }\n\n  return {\n    left,\n    right\n  };\n}\n/**\n * Draw single node\n *\n * @param {BinaryTreeNode} node\n * @param {CanvasComponent} comp\n * @param {PathArray} pathArray\n * @param {Point} position\n * @return {boolean} Weather redraw is required\n */\n\n\nfunction drawSingleNode(node, comp, pathArray, position) {\n  const {\n    x,\n    y\n  } = position;\n  const doesNodeHaveChildren = Boolean(node.left || node.right);\n  node.nodeCircle.setCoordinates(x, y); // Grow or shrink while hover\n\n  const colorId = node.nodeCircle.draw(comp);\n  colorIdToPathMap.set(colorId, pathArray);\n\n  if (colorId === hoveredColorId && doesNodeHaveChildren) {\n    return node.nodeCircle.grow();\n  } else {\n    return node.nodeCircle.restoreCircle();\n  }\n}\n/**\n * Draw both the children if required\n *\n * @param {BinaryTreeNode} node\n * @param {CanvasComponent} comp\n * @param {number} xPosition\n * @param {number} nodeHeight\n * @param {PathArray} pathArray\n * @return {boolean}\n */\n\n\nfunction drawChildren(node, comp, xPosition, nodeHeight, pathArray) {\n  const currentHeight = getCanvasHeightFromTreeHeight(nodeHeight);\n  const childHeight = getCanvasHeightFromTreeHeight(nodeHeight + 1);\n  let requiredRedraw = false; // Draw the left child\n\n  if (node.left) {\n    const currentPathArray = node.left.left || node.left.right ? [...pathArray, 'left'] : [...pathArray];\n    const xLeft = xPosition - 0.5 * theme.leafNodeSpace;\n    requiredRedraw = drawSingleNode(node.left, comp, currentPathArray, {\n      x: xLeft,\n      y: childHeight\n    }) || requiredRedraw;\n    connectPointsWithBezierCurve(comp, {\n      xStart: xPosition,\n      xEnd: xLeft\n    }, {\n      yStart: currentHeight + node.nodeCircle.getRadius(),\n      yEnd: childHeight - node.left.nodeCircle.getRadius()\n    });\n  } // Draw the right child\n\n\n  if (node.right) {\n    const currentPathArray = node.right.left || node.right.right ? [...pathArray, 'right'] : [...pathArray];\n    const xRight = xPosition + 0.5 * theme.leafNodeSpace;\n    requiredRedraw = drawSingleNode(node.right, comp, currentPathArray, {\n      x: xRight,\n      y: childHeight\n    }) || requiredRedraw;\n    connectPointsWithBezierCurve(comp, {\n      xStart: xPosition,\n      xEnd: xRight\n    }, {\n      yStart: currentHeight + node.nodeCircle.getRadius(),\n      yEnd: childHeight - node.right.nodeCircle.getRadius()\n    });\n  }\n\n  return requiredRedraw;\n}\n/**\n * Draw all the nodes by following print array\n *\n * @param {BinaryTreeNode} root\n * @param {CanvasComponent} comp\n * @param {number} xRootPosition\n * @return {boolean} - Weather animated redraw is required\n */\n\n\nfunction drawAllNodes(root, comp, xRootPosition) {\n  // Draw root\n  let currentNode = root;\n  let xPosition = xRootPosition;\n  let currentNodeHeight = 0.5;\n  const currentPathArray = [];\n  let requiredRedraw = drawSingleNode(root, comp, [...currentPathArray], {\n    x: xPosition,\n    y: getCanvasHeightFromTreeHeight(currentNodeHeight)\n  }); // Draw all the children according to the path\n\n  for (const currentPath of globalPathArray) {\n    requiredRedraw = drawChildren(currentNode, comp, xPosition, currentNodeHeight, currentPathArray) || requiredRedraw;\n\n    if (currentPath === 'left') {\n      currentNode = currentNode.left;\n      xPosition = xPosition - 0.5 * theme.leafNodeSpace;\n      currentPathArray.push('left');\n    } else {\n      currentNode = currentNode.right;\n      xPosition = xPosition + 0.5 * theme.leafNodeSpace;\n      currentPathArray.push('right');\n    }\n\n    currentNodeHeight += 1;\n  } // Draw the children of the last element in the path\n\n\n  requiredRedraw = drawChildren(currentNode, comp, xPosition, currentNodeHeight, currentPathArray) || requiredRedraw; // Return if redraw is required\n\n  return requiredRedraw;\n}\n/**\n * Animation frame call back function that will recursively be called.\n * In case animation is required\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} comp\n * @param {IndividualInputOptions} options\n */\n\n\nfunction animationFrameCB(root, comp, options) {\n  // Height and width calculations\n  const nodeHeight = getNodeHeightFromGlobalPathArray();\n  const {\n    left: leftNodeWidth,\n    right: rightNodeWidth\n  } = getNodeWidthFromGlobalPathArray();\n  const requiredHeight = getCanvasHeightFromTreeHeight(nodeHeight + 1);\n  const requiredWidth = getCanvasWidthFromMaxNodeSpacing(leftNodeWidth + rightNodeWidth);\n  const actualHeight = Math.max(requiredHeight, options.maxHeight);\n  const actualWidth = Math.max(requiredWidth, options.maxWidth);\n  const xStart = actualWidth / 2 - requiredWidth / 2; // Set the height and width\n  // This also clears the canvas. So no need to clear it manually.\n\n  comp.setMaxWidthAndHeight(actualHeight, actualWidth); // Initialize color id to path map\n\n  colorIdToPathMap = new Map(); // Draw and check if redraw is required\n\n  const requiredRedraw = drawAllNodes(root, comp, xStart + getXPositionFromGivenHorizontalNodePosition(leftNodeWidth + 1));\n\n  if (requiredRedraw) {\n    requestAnimationFrame(root, comp, options);\n  }\n}\n/**\n * Draw an expandable binary tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {IndividualInputOptions} options\n */\n\n\nfunction drawExpandableBinaryTree(root, canvasComponent, options) {\n  // Initialization\n  globalPathArray = [];\n  /**\n   * Click event handler\n   */\n\n  canvasComponent.onClick(color => {\n    globalPathArray = colorIdToPathMap.get(color) || globalPathArray;\n    requestAnimationFrame(root, canvasComponent, options);\n  });\n  /**\n   * Hover event handler\n   */\n\n  canvasComponent.onHover(color => {\n    hoveredColorId = color;\n    requestAnimationFrame(root, canvasComponent, options);\n  }); // Draw frame\n\n  requestAnimationFrame(root, canvasComponent, options);\n}\n\nexport default drawExpandableBinaryTree;","map":{"version":3,"mappings":"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","names":["theme","getCanvasHeightFromTreeHeight","getCanvasWidthFromMaxNodeSpacing","getXPositionFromGivenHorizontalNodePosition","connectPointsWithBezierCurve","animationFrameId","globalPathArray","hoveredColorId","colorIdToPathMap","Map","requestAnimationFrame","root","comp","options","cancelAnimationFrame","window","animationFrameCB","getNodeHeightFromGlobalPathArray","length","getNodeWidthFromGlobalPathArray","left","right","current","childDirection","Math","max","abs","drawSingleNode","node","pathArray","position","x","y","doesNodeHaveChildren","Boolean","nodeCircle","setCoordinates","colorId","draw","set","grow","restoreCircle","drawChildren","xPosition","nodeHeight","currentHeight","childHeight","requiredRedraw","currentPathArray","xLeft","leafNodeSpace","xStart","xEnd","yStart","getRadius","yEnd","xRight","drawAllNodes","xRootPosition","currentNode","currentNodeHeight","currentPath","push","leftNodeWidth","rightNodeWidth","requiredHeight","requiredWidth","actualHeight","maxHeight","actualWidth","maxWidth","setMaxWidthAndHeight","drawExpandableBinaryTree","canvasComponent","onClick","color","get","onHover"],"sources":["/home/denilson/node_modules/binary-tree-visualizer/src/canvas/drawExpandableBinaryTree.ts"],"sourcesContent":["import CanvasComponent from './Canvas';\nimport theme from '../config/theme';\nimport BinaryTreeNode from '../tree/BinaryTreeNode';\nimport {Point} from '../types/Point';\nimport {\n  getCanvasHeightFromTreeHeight,\n  getCanvasWidthFromMaxNodeSpacing,\n  getXPositionFromGivenHorizontalNodePosition,\n} from '../utils/tree';\nimport {IndividualInputOptions, PathArray} from './types';\nimport connectPointsWithBezierCurve\n  from '../utils/connectPointsWithBezierCurve';\n\n/**\n * The current animation frame that is going on\n */\nlet animationFrameId: number;\n\n/**\n * Array of all children that needs printing\n */\nlet globalPathArray: PathArray;\n\n/**\n * Current color that is being hovered on\n */\nlet hoveredColorId: string;\n\n/**\n * Map storing the colorId to the path array\n */\nlet colorIdToPathMap: Map<string, PathArray> = new Map();\n\n/**\n * Clear the existing animation frame if any and request an animation frame\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} comp\n * @param {IndividualInputOptions} options\n */\nfunction requestAnimationFrame(\n    root: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    options: IndividualInputOptions,\n) {\n  // Clear existing animation frame\n  if (animationFrameId) {\n    cancelAnimationFrame(animationFrameId);\n  }\n\n  // Request a new one\n  animationFrameId = window.requestAnimationFrame(\n      () => animationFrameCB(root, comp, options),\n  );\n}\n\n\n/**\n * Get the node height from print array\n *\n * @return {number}\n */\nfunction getNodeHeightFromGlobalPathArray() {\n  return globalPathArray.length + 1;\n}\n\n\n/**\n * Get the node width from the print array\n *\n * @return {{\n *  left: number,\n *  right: number\n * }}\n */\nfunction getNodeWidthFromGlobalPathArray() {\n  let left = 0;\n  let right = 0;\n  let current = 0;\n\n  for (const childDirection of globalPathArray) {\n    if (childDirection === 'left') {\n      current -= 1;\n    } else {\n      current += 1;\n    }\n    if (current < 0) {\n      left = Math.max(Math.abs(current), left);\n    } else {\n      right = Math.max(current, right);\n    }\n  }\n\n  return {\n    left, right,\n  };\n}\n\n/**\n * Draw single node\n *\n * @param {BinaryTreeNode} node\n * @param {CanvasComponent} comp\n * @param {PathArray} pathArray\n * @param {Point} position\n * @return {boolean} Weather redraw is required\n */\nfunction drawSingleNode(\n    node: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    pathArray: PathArray,\n    position: Point,\n) {\n  const {x, y} = position;\n  const doesNodeHaveChildren = Boolean(node.left || node.right);\n  node.nodeCircle.setCoordinates(x, y);\n\n  // Grow or shrink while hover\n  const colorId = node.nodeCircle.draw(comp);\n  colorIdToPathMap.set(colorId, pathArray);\n  if (colorId === hoveredColorId && doesNodeHaveChildren) {\n    return node.nodeCircle.grow();\n  } else {\n    return node.nodeCircle.restoreCircle();\n  }\n}\n\n/**\n * Draw both the children if required\n *\n * @param {BinaryTreeNode} node\n * @param {CanvasComponent} comp\n * @param {number} xPosition\n * @param {number} nodeHeight\n * @param {PathArray} pathArray\n * @return {boolean}\n */\nfunction drawChildren(\n    node: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    xPosition: number,\n    nodeHeight: number,\n    pathArray: PathArray,\n) {\n  const currentHeight = getCanvasHeightFromTreeHeight(nodeHeight);\n  const childHeight = getCanvasHeightFromTreeHeight(nodeHeight + 1);\n  let requiredRedraw = false;\n\n  // Draw the left child\n  if (node.left) {\n    const currentPathArray : PathArray = node.left.left || node.left.right ?\n      [...pathArray, 'left'] : [...pathArray];\n    const xLeft = xPosition - (0.5 * theme.leafNodeSpace);\n\n    requiredRedraw = drawSingleNode(\n        node.left,\n        comp,\n        currentPathArray, {\n          x: xLeft,\n          y: childHeight,\n        },\n    ) || requiredRedraw;\n    connectPointsWithBezierCurve(comp, {\n      xStart: xPosition,\n      xEnd: xLeft,\n    }, {\n      yStart: currentHeight + node.nodeCircle.getRadius(),\n      yEnd: childHeight - node.left.nodeCircle.getRadius(),\n    });\n  }\n\n  // Draw the right child\n  if (node.right) {\n    const currentPathArray : PathArray = node.right.left || node.right.right ?\n      [...pathArray, 'right'] : [...pathArray];\n    const xRight = xPosition + (0.5 * theme.leafNodeSpace);\n\n    requiredRedraw = drawSingleNode(\n        node.right,\n        comp,\n        currentPathArray, {\n          x: xRight,\n          y: childHeight,\n        },\n    ) || requiredRedraw;\n    connectPointsWithBezierCurve(comp, {\n      xStart: xPosition,\n      xEnd: xRight,\n    }, {\n      yStart: currentHeight + node.nodeCircle.getRadius(),\n      yEnd: childHeight - node.right.nodeCircle.getRadius(),\n    });\n  }\n\n  return requiredRedraw;\n}\n\n\n/**\n * Draw all the nodes by following print array\n *\n * @param {BinaryTreeNode} root\n * @param {CanvasComponent} comp\n * @param {number} xRootPosition\n * @return {boolean} - Weather animated redraw is required\n */\nfunction drawAllNodes(\n    root:BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    xRootPosition: number): boolean {\n  // Draw root\n  let currentNode = root;\n  let xPosition = xRootPosition;\n  let currentNodeHeight = 0.5;\n  const currentPathArray: Array<'left' | 'right'> = [];\n  let requiredRedraw = drawSingleNode(root, comp, [...currentPathArray], {\n    x: xPosition,\n    y: getCanvasHeightFromTreeHeight(currentNodeHeight),\n  });\n\n  // Draw all the children according to the path\n  for (const currentPath of globalPathArray) {\n    requiredRedraw = drawChildren(\n        currentNode,\n        comp,\n        xPosition,\n        currentNodeHeight,\n        currentPathArray,\n    ) || requiredRedraw;\n\n    if (currentPath === 'left') {\n      currentNode = currentNode.left!;\n      xPosition = xPosition - (0.5 * theme.leafNodeSpace);\n      currentPathArray.push('left');\n    } else {\n      currentNode = currentNode.right!;\n      xPosition = xPosition + (0.5 * theme.leafNodeSpace);\n      currentPathArray.push('right');\n    }\n    currentNodeHeight += 1;\n  }\n\n  // Draw the children of the last element in the path\n  requiredRedraw = drawChildren(\n      currentNode,\n      comp,\n      xPosition,\n      currentNodeHeight,\n      currentPathArray,\n  ) || requiredRedraw;\n\n  // Return if redraw is required\n  return requiredRedraw;\n}\n\n/**\n * Animation frame call back function that will recursively be called.\n * In case animation is required\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} comp\n * @param {IndividualInputOptions} options\n */\nfunction animationFrameCB(\n    root: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    options: IndividualInputOptions,\n) {\n  // Height and width calculations\n  const nodeHeight = getNodeHeightFromGlobalPathArray();\n  const {\n    left: leftNodeWidth,\n    right: rightNodeWidth,\n  } = getNodeWidthFromGlobalPathArray();\n  const requiredHeight = getCanvasHeightFromTreeHeight(nodeHeight + 1);\n  const requiredWidth = getCanvasWidthFromMaxNodeSpacing(\n      leftNodeWidth+rightNodeWidth,\n  );\n  const actualHeight = Math.max(requiredHeight, options.maxHeight);\n  const actualWidth = Math.max(requiredWidth, options.maxWidth);\n  const xStart = (actualWidth/2) - (requiredWidth/2);\n\n  // Set the height and width\n  // This also clears the canvas. So no need to clear it manually.\n  comp.setMaxWidthAndHeight(actualHeight, actualWidth);\n\n  // Initialize color id to path map\n  colorIdToPathMap = new Map();\n\n  // Draw and check if redraw is required\n  const requiredRedraw = drawAllNodes(\n      root,\n      comp,\n      xStart + getXPositionFromGivenHorizontalNodePosition(leftNodeWidth + 1),\n  );\n  if (requiredRedraw) {\n    requestAnimationFrame(root, comp, options);\n  }\n}\n\n/**\n * Draw an expandable binary tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {IndividualInputOptions} options\n */\nfunction drawExpandableBinaryTree(\n    root: BinaryTreeNode<string | number>,\n    canvasComponent: CanvasComponent,\n    options: IndividualInputOptions,\n) {\n  // Initialization\n  globalPathArray = [];\n\n  /**\n   * Click event handler\n   */\n  canvasComponent.onClick((color) => {\n    globalPathArray = colorIdToPathMap.get(color) || globalPathArray;\n    requestAnimationFrame(root, canvasComponent, options);\n  });\n\n  /**\n   * Hover event handler\n   */\n  canvasComponent.onHover((color) => {\n    hoveredColorId = color;\n    requestAnimationFrame(root, canvasComponent, options);\n  });\n\n  // Draw frame\n  requestAnimationFrame(root, canvasComponent, options);\n}\n\nexport default drawExpandableBinaryTree;\n"]},"metadata":{},"sourceType":"module"}