{"ast":null,"code":"import BinaryTreeNode from './BinaryTreeNode';\n/**\n * A Binary search tree node\n */\n\nclass BinarySearchTreeNode extends BinaryTreeNode {\n  /**\n   * Set the left child of the node\n   *\n   * @param {BinarySearchTreeNode<T>} value\n   */\n  setLeft(value) {\n    super.setLeft(value);\n  }\n  /**\n   * Set the right child of the node\n   *\n   * @param {BinarySearchTreeNode<T>} value\n   */\n\n\n  setRight(value) {\n    super.setRight(value);\n  }\n  /**\n   * Insert a value into the node\n   * (Using Recursion)\n   *\n   * @param {T} value\n   */\n\n\n  insert(value) {\n    // Skip equal value\n    if (value === this.value) {\n      return;\n    } // When value is lesser\n\n\n    if (value < this.value) {\n      if (this.left) {\n        this.left.insert(value);\n        return;\n      }\n\n      this.setLeft(new BinarySearchTreeNode(value));\n      return;\n    } // When value is greater\n\n\n    if (this.right) {\n      this.right.insert(value);\n      return;\n    }\n\n    this.setRight(new BinarySearchTreeNode(value));\n  }\n  /**\n   * Find the minimum value from the given node\n   *\n   * @param {BinarySearchTreeNode<T>} node\n   * @return {BinarySearchTreeNode<T>}\n   */\n\n\n  findMinimum() {\n    if (this.left) {\n      return this.left.findMinimum();\n    }\n\n    return this;\n  }\n  /**\n   * Delete this node\n   *\n   * @param {BinarySearchTreeNode<T>} parent\n   * @return {[\n   *  BinarySearchTreeNode<T>,\n   *  BinarySearchTreeNode<T>\n   * ]} [deletedNode, currentRoot]\n   */\n\n\n  deleteThisNode(parent) {\n    // Which direction is this node from the parent\n    const childDirection = (parent === null || parent === void 0 ? void 0 : parent.left) === this ? 'left' : 'right'; // Case 1: Delete leaf node\n\n    if (!this.left && !this.right) {\n      if (parent) {\n        delete parent[childDirection];\n      }\n\n      return [this];\n    } // Case 2: Delete when there is only one child\n\n\n    if (this.left && !this.right) {\n      if (parent) {\n        parent[childDirection] = this.left;\n      }\n\n      return [this, this.left];\n    } else if (this.right && !this.left) {\n      if (parent) {\n        parent[childDirection] = this.right;\n      }\n\n      return [this, this.right];\n    } // Case 3: There are 2 children\n    // Step 1: Delete the in order successor\n\n\n    const [deletedNode] = this.right.delete(this.right.findMinimum().value, this); // Step 2: Set the in order successor as the current node\n    // Deleted node will always be found\n\n    deletedNode.left = this.left;\n    deletedNode.right = this.right;\n\n    if (parent) {\n      parent[childDirection] = deletedNode;\n    }\n\n    return [this, deletedNode];\n  }\n  /**\n   * Delete a node\n   * (Using recursion)\n   *\n   * @param {T} value\n   * @param {BinarySearchTreeNode<T>} parent\n   * @return {[\n   *  BinarySearchTreeNode<T>,\n   *  BinarySearchTreeNode<T>\n   * ]} [deletedNode, currentRoot]\n   */\n\n\n  delete(value, parent) {\n    // Delete from left node\n    if (value < this.value && this.left) {\n      const [deletedNode] = this.left.delete(value, this);\n      return [deletedNode, this];\n    } // Delete from right node\n\n\n    if (value > this.value && this.right) {\n      const [deletedNode] = this.right.delete(value, this);\n      return [deletedNode, this];\n    } // Delete the current node\n\n\n    if (this.value === value) {\n      const res = this.deleteThisNode(parent);\n      delete this.left;\n      delete this.right;\n      return res;\n    }\n\n    return [, this];\n  }\n\n}\n\nexport default BinarySearchTreeNode;","map":{"version":3,"mappings":"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","names":["BinaryTreeNode","BinarySearchTreeNode","setLeft","value","setRight","insert","left","right","findMinimum","deleteThisNode","parent","childDirection","deletedNode","delete","res"],"sources":["/home/denilson/node_modules/binary-tree-visualizer/src/tree/BinarySearchTreeNode.ts"],"sourcesContent":["import BinaryTreeNode from './BinaryTreeNode';\n\n/**\n * A Binary search tree node\n */\nclass BinarySearchTreeNode<T extends string | number>\n  extends BinaryTreeNode<T> {\n    /**\n     * Left child of the node\n     */\n    left?: BinarySearchTreeNode<T>\n\n    /**\n     * Right child of the node\n     */\n    right?: BinarySearchTreeNode<T>\n\n    /**\n     * Set the left child of the node\n     *\n     * @param {BinarySearchTreeNode<T>} value\n     */\n    setLeft(value: BinarySearchTreeNode<T>) {\n      super.setLeft(value);\n    }\n\n    /**\n     * Set the right child of the node\n     *\n     * @param {BinarySearchTreeNode<T>} value\n     */\n    setRight(value: BinarySearchTreeNode<T>) {\n      super.setRight(value);\n    }\n\n    /**\n     * Insert a value into the node\n     * (Using Recursion)\n     *\n     * @param {T} value\n     */\n    insert(value: T) {\n      // Skip equal value\n      if (value === this.value) {\n        return;\n      }\n\n      // When value is lesser\n      if (value < this.value) {\n        if (this.left) {\n          this.left.insert(value);\n          return;\n        }\n        this.setLeft(new BinarySearchTreeNode(value));\n        return;\n      }\n\n      // When value is greater\n      if (this.right) {\n        this.right.insert(value);\n        return;\n      }\n      this.setRight(new BinarySearchTreeNode(value));\n    }\n\n    /**\n     * Find the minimum value from the given node\n     *\n     * @param {BinarySearchTreeNode<T>} node\n     * @return {BinarySearchTreeNode<T>}\n     */\n    findMinimum():BinarySearchTreeNode<T> {\n      if (this.left) {\n        return this.left.findMinimum();\n      }\n      return this;\n    }\n\n    /**\n     * Delete this node\n     *\n     * @param {BinarySearchTreeNode<T>} parent\n     * @return {[\n     *  BinarySearchTreeNode<T>,\n     *  BinarySearchTreeNode<T>\n     * ]} [deletedNode, currentRoot]\n     */\n    deleteThisNode(\n        parent?: BinarySearchTreeNode<T>,\n    ): [BinarySearchTreeNode<T>?, BinarySearchTreeNode<T>?] {\n      // Which direction is this node from the parent\n      const childDirection = parent?.left === this ? 'left' : 'right';\n\n      // Case 1: Delete leaf node\n      if (!this.left && !this.right) {\n        if (parent) {\n          delete parent[childDirection];\n        }\n        return [this];\n      }\n\n      // Case 2: Delete when there is only one child\n      if (this.left && !this.right) {\n        if (parent) {\n          parent[childDirection] = this.left;\n        }\n        return [this, this.left];\n      } else if (this.right && !this.left) {\n        if (parent) {\n          parent[childDirection] = this.right;\n        }\n        return [this, this.right];\n      }\n\n      // Case 3: There are 2 children\n\n      // Step 1: Delete the in order successor\n      const [deletedNode] = this.right!.delete(\n        this.right!.findMinimum().value, this,\n      );\n\n      // Step 2: Set the in order successor as the current node\n      // Deleted node will always be found\n      deletedNode!.left = this.left;\n      deletedNode!.right = this.right;\n      if (parent) {\n        parent[childDirection] = deletedNode;\n      }\n\n      return [this, deletedNode];\n    }\n\n    /**\n     * Delete a node\n     * (Using recursion)\n     *\n     * @param {T} value\n     * @param {BinarySearchTreeNode<T>} parent\n     * @return {[\n     *  BinarySearchTreeNode<T>,\n     *  BinarySearchTreeNode<T>\n     * ]} [deletedNode, currentRoot]\n     */\n    delete(\n        value: T,\n        parent?: BinarySearchTreeNode<T>,\n    ): [BinarySearchTreeNode<T>?, BinarySearchTreeNode<T>?] {\n      // Delete from left node\n      if (value < this.value && this.left) {\n        const [deletedNode] = this.left.delete(value, this);\n        return [deletedNode, this];\n      }\n\n      // Delete from right node\n      if (value > this.value && this.right) {\n        const [deletedNode] = this.right.delete(value, this);\n        return [deletedNode, this];\n      }\n\n      // Delete the current node\n      if (this.value === value) {\n        const res = this.deleteThisNode(parent);\n        delete this.left;\n        delete this.right;\n        return res;\n      }\n\n      return [, this];\n    }\n}\n\nexport default BinarySearchTreeNode;\n"]},"metadata":{},"sourceType":"module"}